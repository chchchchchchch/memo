
# SAVE FOR NOW: BACKWARDS COMPATIBILITY
# ---------------------------------------------------------------------------- #

function mkqr(){ sleep 0; }
function QR(){ HREF $* ;}

# OVERWRITE
# ---------------------------------------------------------------------------- #
  function refsrc() {

    mkqr $* > /dev/null 2>&1
    REFCODE="\qrmargin{$QRPDF}{$QRTXT}"
    echo "$REFCODE"

  }
# --------------------------------------------------------------------------- #


# --------------------------------------------------------------------------- #
  QRDEKOSRC=EDIT/151007_qrdeko-simple.svg
   QRURLLOG=${TMPID}.qrurls
# --------------------------------------------------------------------------- #

  function mkqr() {

  QURL=`shortref "$*"`
  QRID=`echo $QURL | rev | cut -d "/" -f 1 | rev`
  QRTXT=`echo $QRID | tr [:lower:] [:upper:]`

  QRPDF=$TMPID${QRID}.pdf
  QRDEKO=${TMPID}DEKO

  if [ ! -f $QRPDF ]; then

  SCALE="scale(0.1,-0.1)"
  MOVE="translate(55,145)"
  TRANSFORMQR="transform=\"$MOVE$SCALE\""

  echo $QURL >> $QRURLLOG

# SELECT LAYERS: ONE FOR EACH UNIQUE NAME
# --------------------------------------------------------------------------- #
  sed ":a;N;\$!ba;s/\n/ /g" $QRDEKOSRC  | # REMOVE ALL LINEBREAKS
  sed 's/<g/\n<g/g'                     | # RESTORE GROUP OPEN + NEWLINE
  sed '/groupmode="layer"/s/<g/4Fgt7R/g'| # PLACEHOLDER FOR LAYERGROUP OPEN
  sed ':a;N;$!ba;s/\n/ /g'              | # REMOVE ALL LINEBREAKS
  sed 's/4Fgt7R/\n<g/g'                 | # RESTORE LAYERGROUP OPEN + NEWLINE
  sed 's/display:none/display:inline/g' | # MAKE VISIBLE EVEN WHEN HIDDEN
  tee head.tmp                          | # DUMP NOW TO EXTRACT HEAD LATER
  tail -n +2                            | # REMOVE HEAD (=FIRST LINE)
  sed 's/<\/svg>//g'                    | # REMOVE CLOSING TAG
  grep -n ""                            | # NUMBER LINES
  sed "s/^.*$/&|&/g"                    | # DOUBLE CONTENT FOR ANALYSIS
  sed "s/:label/\nX1X/"                 | # MARK LABEL (=NAME)
  grep -v ":label=\"XX_"                | # IGNORE XX LAYERS
  grep  "^X1X"                          | # SELECT MARKED
  shuf                                  | # SHUFFLE
  sort -u -t\" -k1,2                    | # SELECT ONE FOR EACH LABEL
  cut -d "|" -f 2-                      | # SELECT SECOND/UNTOUCHED CONTEN
  sort -n -u -t: -k1,1                  | # SORT ACCORDING TO LINE NUMBER
  cut -d ":" -f 2-                      | # REMOVE LINENUMBER
  tee  > layers.tmp                       # WRITE TO FILE
# --------------------------------------------------------------------------- #

  head -n 1 head.tmp                      >  ${QRDEKO}.svg
  cat layers.tmp | sed "s/VWXYZ/$QRTXT/g" >> ${QRDEKO}.svg
  echo "$QURL" | qrencode -iv 1 -t EPS -o $TMPID${QRID}.eps
  inkscape --export-plain-svg=$TMPID${QRID}.svg \
           $TMPID${QRID}.eps
  echo "<g $TRANSFORMQR>"  >> ${QRDEKO}.svg
  sed ':a;N;$!ba;s/\n/ /g' $TMPID${QRID}.svg | \
  tr -s ' ' | sed 's/</\n&/g' | #
  grep "^<path"            >> ${QRDEKO}.svg
  echo "</g>"              >> ${QRDEKO}.svg
  echo "</svg>"            >> ${QRDEKO}.svg
  inkscape --export-pdf=$QRPDF  \
           --export-text-to-path \
           ${QRDEKO}.svg
# CLEAN UP
  rm *.tmp $TMPID${QRID}.eps $TMPID${QRID}.svg ${QRDEKO}.svg

  else
       echo "qr graphic for $QURL already generated!"
  fi
  }
# --------------------------------------------------------------------------- #

# =========================================================================== #
#  S H A R E D
# =========================================================================== #
  SHORTURLBASE="http://lfkn.de"
  SRCLIST=${TMPID}X.list

# =========================================================================== #

 function listSrc() {

  if [ `echo $* | wc -c` -lt 2 ]; then   # = NO PARAMETERS PROVIDED 
       SEP="% ------------"              # THIS IS THE SEPARATOR
      SEPN=`grep -n "" $SRCDUMP             | # NUMBER LINES
            egrep "$SEP|^[0-9]*:$EMPTYLINE" | # LOCATE SEPARATOR OR EMPTY LINE
            tail -n 1                       | # SELECT LAST 
            cut -d ":" -f 1`                  # SELECT FIRST FIELD
       sed "1,${SEPN}d" $SRCDUMP   | # PRINT FROM LINE NUM TO END
       grep -v "^% QUAVERBATIM"    | # IGNORE COMMAND ITSELF
       sed "s/^%//"                | # REMOVE LEADING %
       sed "s/^[ ]*//"             | # REMOVE ALL LEADING BLANKS
       sed "/^[ \t]*$/d"           | # REMOVE EMPTY LINES
       tee      > $SRCLIST
  else 
       echo $*  > $SRCLIST
  fi

 }

# =========================================================================== #

 function getFileRange() {
 
   COLLECTED=$TMPID.srccollected
 
 ( IFS=$'\n'

  if [ -f $SRCLIST ]; then
   for THISSRC in `cat $SRCLIST`
    do
       SRCURL=`echo $THISSRC | sed 's/ /\n/g'   | # SPACES TO NEWLINES
               sed "/\.functions$/s/^/XXX/g"    | # MARK LINES WITH .functions EXTENSION
               sed "/\.[a-z]\{2,4\}$/s/^/XXX/g" | # MARK LINES WITH 2-4 CHAR EXT
               grep "^XXX" | sed 's/^XXX//'     | # SELECT AND REMOVE MARK
               head -n 1`                         # SELECT FIRST
        LINES=`echo $THISSRC | sed "s/ /\n/g"   | # SPACES TO NEWLINES
               sed "/[^0-9\\-]/d"               | # NO LINES WITH MORE THAN NUMS AND -
               egrep -v "^-|-$"                 | # IGNORE ISOLATED - 
               grep -v "^[ ]*$" | tail -n 1`      # LAST LINE ONLY
       if [ `echo $LINES | wc -c` -gt 1 ]; then   # IF LINE OPTION IS SET
             LINES=`echo $LINES | sed 's/-/,/'`
             SELECTSRCLINES="sed -n \"${LINES}p\" "
       else                                       # IF LINE OPTION IS NOT SET
             SELECTSRCLINES="tee"
       fi
       SRCGET=${TMPID}SRC`echo $SRCURL | md5sum | cut -c 1-3`.txt  
       if [ ! -f $SRCGET ]; then
            getFile $SRCURL $SRCGET
       fi;  if [ -f $SRCGET ]; then
            cat   $SRCGET                 | # START WITH ALL
            eval "$SELECTSRCLINES"        | # DO SELECT LINE RANGE
            tee                           >> $COLLECTED
     fi
   done 
  fi
 )
   if [ -f $COLLECTED ]; then
   INDENT=`cat $COLLECTED        | # START PIPE WITH COLLECTION
           sed '/^[ \t]*$/d'     | # IGNORE/DELETE EMPTY LINES
           sed -E 's/([^ ]).*//' | # KEEP ONLY LEADING BLANK
           sort -r               | # REVERSE SORT
           tail -n 1             | # SELECT LAST (=SHORTEST)
           wc -c`                  # COUNT  
   if [ $INDENT -eq 0 ]; then INDENT=1 ; fi
   fi
 }

# =========================================================================== #

 function conformColor() {

      ( CHECK=$1
        gs -dNumRenderingThreads=4 \
           -dNOPAUSE -sDEVICE=jpeg \
           -dFirstPage=1 -dLastPage=1 \
           -sOutputFile=./checkcolor.jpg \
           -dJPEGQ=20 -r50 \
           -q $CHECK -c quit
   
        HASCOLOR=`convert checkcolor.jpg -colorspace HSL \
                 -format '%[fx:maxima.g]' info: | sed 's/[^0-9]//g'`
        if [ $HASCOLOR -eq 0 ]; then
              pdfxgs $CHECK
              sleep 0
        else
             #pdfxcmyk $CHECK
              pdfxgs $CHECK
              sleep 0
        fi  
        rm checkcolor.jpg
      )
  }

# =========================================================================== #

  function svglayers2pdfpages() {

   CROP=10.63 # 3mm in px

     SVGLAYER=$1
     PDFPAGES=$2
     SUPERTMP=${TMPID}.`echo $SVGL | md5sum | cut -c 1-4`.tmp
 
     CANVASWIDTH=`sed ":a;N;\$!ba;s/\n//g" $SVGLAYER | # SVG WITHOUT LINEBREAKS
                  sed 's/width=/\n&/g'               | # EXTRACT WIDTH
                  grep "^width="                     | # EXTRACT WIDTH
                  cut -d "\"" -f 2                   | # EXTRACT WIDTH VALUE
                  head -n 1`                           # FIRST WIDTH ONLY
      LAYERNAMES=`sed ":a;N;\$!ba;s/\n//g" $SVGLAYER | # SVG WITHOUT LINEBREAKS
                  sed 's/nkscape:label/\n&/g'        | # EXTRACT LAYER NAME
                  grep "^nkscape:label"              | # EXTRACT LAYER NAME
                  cut -d "\"" -f 2                   | # EXTRACT LAYER NAME
                  grep -v XX_                        | # IGNORE XX_LAYERS
                  sort -u`                             # SORT AND UNIQ
 
     BFOO=NL`echo ${RANDOM} | cut -c 1`F00
     SFOO=SP`echo ${RANDOM} | cut -c 1`F0O
   # ----------------------------------------------------------------------- #
   # MOVE LAYERS ON SEPARATE LINES (TEMPORARILY; EASIFY PARSING LATER ON)
   # ----------------------------------------------------------------------- #
     sed ":a;N;\$!ba;s/\n/$BFOO/g" $SVGLAYER | # REMOVE ALL LINEBREAKS (BUT SAVE)
     sed "s/ /$SFOO/g"                       | # REMOVE ALL SPACE (BUT SAVE)
     sed 's/<g/4Fgt7RfjIoPg7/g'              | # PLACEHOLDER FOR GROUP OPEN
     sed ':a;N;$!ba;s/\n/ /g'                | # REMOVE ALL NEW LINES
     sed 's/4Fgt7RfjIoPg7/\n<g/g'            | # RESTORE GROUP OPEN + NEWLINE
     sed '/groupmode="layer"/s/<g/4Fgt7R/g'  | # PLACEHOLDER FOR LAYERGROUP OPEN
     sed ':a;N;$!ba;s/\n/ /g'                | # REMOVE ALL LINEBREAKS
     sed 's/4Fgt7R/\n<g/g'                   | # RESTORE LAYERGROUP OPEN + NEWLINE
     sed 's/<\/svg>//g'                      | # REMOVE SVG CLOSE
     sed 's/display:none/display:inline/g'   | # MAKE VISIBLE EVEN WHEN HIDDEN
     tee > ${SUPERTMP}                         # WRITE TO TEMPORARY FILE
   # ----------------------------------------------------------------------- #
   # WRITE LAYERS TO SEPARATE FILES AND TRANSFORM TO PDF 
   # ----------------------------------------------------------------------- #
     COUNT=1 
     for LAYERNAME in $LAYERNAMES
      do
         for PAGE in 1 2
         do
             if [ $PAGE -eq 1 ]; then
                  XSHIFT=-$CROP
             else
                  XSHIFT=-`python -c "print $CANVASWIDTH - $CROP"`
             fi
             TRANSFORM="transform=\"translate($XSHIFT,0)\""
             NUM=`echo 0000$COUNT | rev | cut -c 1-4 | rev`
             LNAME=`echo $LAYERNAME | md5sum | cut -c 1-6`

                head -n 1 ${SUPERTMP}  | # THE HEADER
                sed "s/$BFOO/\n/g"     | # RESTORE ORIGINAL LINEBREAKS
                sed "s/$SFOO/ /g"      | # RESTORE ORIGINAL SPACES
                tee                    >   ${TMPID}_${NUM}_${LNAME}.svg
                echo "<g $TRANSFORM>"  >>  ${TMPID}_${NUM}_${LNAME}.svg
                grep "inkscape:label=\"$LAYERNAME\"" ${SUPERTMP} | #
                sed "s/$BFOO/\n/g"     | # RESTORE ORIGINAL LINEBREAKS
                sed "s/$SFOO/ /g"      | # RESTORE ORIGINAL SPACES
                tee                    >>  ${TMPID}_${NUM}_${LNAME}.svg
                echo "</g>"            >>  ${TMPID}_${NUM}_${LNAME}.svg
                echo "</svg>"          >>  ${TMPID}_${NUM}_${LNAME}.svg 
    
                inkscape --export-pdf=${TMPID}_${NUM}_${LNAME}.pdf \
                         --export-text-to-path \
                         ${TMPID}_${NUM}_${LNAME}.svg
   
                conformColor ${TMPID}_${NUM}_${LNAME}.pdf

                rm ${TMPID}_${NUM}_${LNAME}.svg

             COUNT=`expr $COUNT + 1`
         done
     done
   # ----------------------------------------------------------------------- #
   # MAKE MULTIPAGE PDF
   # ----------------------------------------------------------------------- #
     pdftk ${TMPID}_*.pdf cat output $PDFPAGES
   # ----------------------------------------------------------------------- #
   # CLEAN UP(OBSOLETE?)
   # ----------------------------------------------------------------------- #
     rm ${TMPID}_*.pdf $SVGLAYER
 
  }

# =========================================================================== #

 function mkpages() {

   FIRSTPAGEIS="" # RESET
 
   PDFSRC=`echo $* | sed 's/ /\n/g'    | # SPACES TO NEWLINES
           egrep "\.svg$|\.pdf$"       | # SELECT ENDING WITH .svg/.pdf
           head -n 1`                    # SELECT FIRST
    PAGES=`echo $* | sed 's/ /\n/g'    | # SPACES TO NEWLINES
           sed "/[^0-9\\-]/d"          | # NO LINES WITH MORE THAN NUMS AND -
           egrep -v "^-|-$"            | # IGNORE ISOLATED - 
           grep -v "^[ ]*$" | tail -n 1` # 
      EXT=`echo $PDFSRC | rev | cut -d "." -f 1 | rev`
 
   if [ `echo $PAGES | wc -c` -le 1 ]; then
         PAGES=-
   elif [ `echo $PAGES | grep "^[0-9]" | wc -l` -ge 1 ]; then
         P1=`echo $PAGES | cut -d "-" -f 1`
         if [ `python -c "print $P1 / 2.0" | #
               cut -d "." -f 2` -lt 5 ]; then
               FIRSTPAGEIS="even"
         else
               FIRSTPAGEIS="odd"
         fi
   else
         PAGES=- ; PAGECOMMAND=""
   fi
 
   PDFGET=${TMPID}`echo $PDFSRC | md5sum | cut -c 1-6`.pdf
   SVGTMP=${TMPID}`echo $PDFSRC | md5sum | cut -c 4-9`.svg
 
   if [ -f $PDFGET ]; then
        echo "$PDFGET exists"
   else 
        if [ "X$EXT" == "Xsvg" ]; then
    
              getFile $PDFSRC $SVGTMP
    
        if [ "X$SUCCESS" == "XYES" ]; then
              SVGTMP=`realpath $SVGTMP`
              svglayers2pdfpages $SVGTMP $PDFGET
        fi
    
        elif [ "X$EXT" == "Xpdf" ]; then
    
               getFile $PDFSRC $PDFGET   
               conformColor $PDFGET
        fi
   fi
 }

# =========================================================================== #


# --------------------------------------------------------------------------- #

function QUAVERBATIM() {(

  listSrc $*
  getFileRange

  if [ -f $COLLECTED ]; then

     if [ "X$HREFMODE" != "XOFF"  ]; then
           WWWLINK=`shortref $*`
           REFCODE=`refsrc $WWWLINK`
           write2src "$REFCODE"
     fi

  # ------------------------------------------------------------------------- #
    write2src "\begin{quaverbatim}"

     cat $COLLECTED      | # START ...
     cut -c ${INDENT}-   | # REMOVE INDENT
     tee >> $SRCDUMP       # WRITE TO FILE

    write2src "\end{quaverbatim}"
  # ------------------------------------------------------------------------- #

  rm $COLLECTED

  fi

  if [ -f $SRCLIST ]; then rm $SRCLIST ;fi

)}

# --------------------------------------------------------------------------- #

function SRCODE() {(

  listSrc $*
  getFileRange

  SRCSRC=`tail -n 1 $SRCLIST | sed 's/ /\n/g' | # LAST ENTRY FROM SRCLIST SPACES TO NEWLINES
          sed "/\.functions$/s/^/XXX/g"       | # MARK LINES WITH .functions EXTENSION
          sed "/\.[a-z]\{2,4\}$/s/^/XXX/g"    | # MARK LINES WITH 2-4 CHARACTER EXTENSION
          grep "^XXX" | sed 's/^XXX//'        | # SELECT AND REMOVE MARK
          head -n 1`                            # SELECT FIRST
  EXTENSION=`echo $SRCSRC | rev | cut -d "." -f 1 | rev`

     if   [ "X$EXTENSION" == "Xsh" ]; then
             LSTSET="\lstsetBash"
     elif [ "X$EXTENSION" == "Xfunctions" ]; then
             LSTSET="\lstsetBash"
     elif [ "X$EXTENSION" == "Xtex" ]; then
             LSTSET="\lstsetTeX"
     elif [ "X$EXTENSION" == "Xsty" ]; then
             LSTSET="\lstsetTeX"
     else
             LSTSET="\lstReset"
     fi

  if [ -f $COLLECTED ]; then

     if [ "X$HREFMODE" != "XOFF"  ]; then
           WWWLINK=`shortref $*`
           REFCODE=`refsrc $WWWLINK`
           write2src "$REFCODE"
     fi

  # ------------------------------------------------------------------------- #
    write2src "\begin{lstlisting}"

     cat $COLLECTED                     | # START ...
     cut -c ${INDENT}-                  | # REMOVE INDENT
     sed 's/^[ \t]*$/°\\emptylinelst°/' | # REPLACE EMPTY LINES WITH COMMAND
     tee >> $SRCDUMP       # WRITE TO FILE

    write2src "\end{lstlisting}"
  # ------------------------------------------------------------------------- #

  rm $COLLECTED

  fi

  if [ -f $SRCLIST ]; then rm $SRCLIST ;fi

)}

# --------------------------------------------------------------------------- #

function SOFTWAREUSED() {

    getFile $1 ${TMPID}softwareused.tmp
    write2src "\begin{quaverbatim}"

     cat ${TMPID}softwareused.tmp | # START ...
     tee >> $SRCDUMP                # WRITE TO FILE

    write2src "\end{quaverbatim}"
    rm ${TMPID}softwareused.tmp
}

# --------------------------------------------------------------------------- #

function PDF() {(

  listSrc $*

 ( IFS=$'\n'
  for ITEM in `cat $SRCLIST`
   do
      PDFSRC=`echo $ITEM | sed 's/ /\n/g'  | # SPACES TO NEWLINES
              grep "\.pdf$" | head -n 1`     # SELECT FIRST ENDING WITH .pdf 
       PAGES=`echo $ITEM | sed "s/#/\n#/g" | # HASH TO NEWLINES
              grep -v "^#"                 | # IGNORE HASH LINES
              sed 's/ /\n/g'               | # SPACES TO NEWLINES
              sed "/[^0-9\\-]/d"           | # NO LINES WITH MORE THAN NUMS AND -
              egrep -v "^-|-$"             | # IGNORE ISOLATED - 
              grep -v "^[ ]*$" | tail -n 1`  # NO EMPTY / LAST LINE ONLY

      if [ `echo $PAGES | wc -c` -le 1 ]; then
            PAGES=-
      fi
      OPTIONS=`echo $ITEM | sed "s/#/\n#/g"       | #
               grep "^#" | tail -n 1              | #
               cut -d "#" -f 2 | sed 's/^[ \t]*//'` # 
      if [ `echo $OPTIONS | wc -c` -gt 1 ]; then
            OPTIONS=",$OPTIONS"
     # else echo "no options provided"
      fi

   PDFGET=${TMPID}`echo $PDFSRC | md5sum | cut -c 1-4`.pdf
   if [ ! -f $PDFGET ]; then
         getFile $PDFSRC $PDFGET
  # else echo "no need to download"
   fi

   if [ -f $PDFGET ]; then

      conformColor $PDFGET

     if [ "X$HREFMODE" != "XOFF"  ]; then
           WWWLINK=`shortref $*`
           REFCODE=`refsrc $WWWLINK | sed 's/qrmargin/qroverlay/'`
           write2src "\newpage"
           write2src "$REFCODE"
     fi
           write2src "\pdfpage{$PDFGET}{$PAGES}{$OPTIONS}"
   fi

  done )

  if [ -f $SRCLIST ]; then rm $SRCLIST ;fi

)}

# --------------------------------------------------------------------------- #

function SPREAD() {

   mkpages $*
   MACRO="% something went wrong with $SVGSRC"
   if   [ "P$FIRSTPAGEIS" == "Podd" ]; then
           PAGECOMMAND="\cleartoleft"
   elif [ "P$FIRSTPAGEIS" == "Peven" ]; then
           PAGECOMMAND="\cleartoright"
   else  # ALL PAGES
         # PAGECOMMAND=""
           PAGECOMMAND="\cleartoleft" # P1 = 1
   fi
   if [ `echo $PAGES | grep -v "-" | # RM - AND 0-9 => 2 -gt 0
         wc -l` -gt 0 ]; then  PAGECOMMAND=""; fi

   if [ -f $PDFGET ]; then
   MACRO="\spread{$PDFGET}{$PAGES}{$PAGECOMMAND}"
   fi

   write2src "$MACRO"

}

# --------------------------------------------------------------------------- #

function SHOWASAP() {

   mkpages $*
   REF=`echo $RANDOM | md5sum | cut -c 1-9`

   MACRO="% something went wrong with $SVGSRC"

   if [ `echo $PAGES | sed '/^[0-9]/!d' | wc -l` -gt 0 ]; then
         P=`echo $PAGES | cut -d "-" -f 1`
   else
         P=1
   fi

   if [ -f $PDFGET ]; then
      MACRO="\fullpagefloat{$PDFGET}{$P}{$REF}"
   fi

   write2src "$MACRO"
}

# --------------------------------------------------------------------------- #

function SUPERIMPOSE() {

  SVGSRC=`echo $* | sed 's/ /\n/g'    | # SPACES TO NEWLINES
          grep "\.svg$" | head -n 1`    # SELECT FIRST ENDING WITH .pdf 
   PAGES=`echo $* | sed "s/#/\n#/g"   | # HASH TO NEWLINES
          grep -v "^#"                | # IGNORE LINES STARTING WITH HASH
          sed 's/ /\n/g'              | # SPACES TO NEWLINES
          sed "/[^0-9\\-]/d"          | # NO LINES WITH MORE THAN NUMS AND -
          grep -v "^[ ]*$" | tail -n 1` # IGNORE EMPTY LINES, TAKE LAST MATCH
  if [ `echo $PAGES | wc -c` -le 1 ]; then
        PAGES=1
  fi

  P1=`echo $PAGES | cut -d "-" -f 1`
  P2=`echo $PAGES | cut -d "-" -f 2`

     PDF=${TMPID}`echo $SVGSRC | md5sum | cut -c 1-4`.pdf
  SVGTMP=${TMPID}`echo $SVGSRC | md5sum | cut -c 1-4`.svg
   MACRO="% something went wrong with $SVGSRC"

    if [ -f $PDF ]; then
      #echo "$PDF exists"
       MACRO="\superimpose{$PDF}{$P1}{$P2}"
  else

  ISSVG=`echo $SVGSRC | grep "\.svg$" | wc -l`
  if [ $ISSVG -gt 0 ]; then

    getFile $SVGSRC $SVGTMP
    echo $PDF

    if [ "X$SUCCESS" == "XYES" ]; then

    svglayers2pdfpages $SVGTMP $PDF

  # ----------------------------------------------------------------------- #
  # INCLUDE IN DOCUMENT
  # ----------------------------------------------------------------------- #
    MACRO="\superimpose{$PDF}{$P1}{$P2}"

   fi
  fi
 fi

 write2src "$MACRO"

}

# --------------------------------------------------------------------------- #

function PP(){(

   PPCOLLECT="" # RESET
     PPPAGES="" # RESET
     REFCODE="" # RESET
       PPSEP="% -----------------"
    PPSEPNUM=`grep -n "" $SRCDUMP               | # NUMBER LINES
              egrep "$PPSEP|^[0-9]*:$EMPTYLINE" | # LOCATE SEPARATOR OR EMPTY LINE
              tail -n 1                         | # SELECT LAST 
              cut -d ":" -f 1`                    # SELECT FIRST FIELD

  # REFID=`echo $*             | # START PIPE
  #        sed 's/REF:/\n&/'   | #
  #        grep "^REF:"        | #
  #        head -n 1           | #
  #        cut -d ":" -f 2     | #
  #        sed 's/^[ \t]*//'   | # REMOVE LEADING WHITESPACE
  #        sed 's/[ \t]*$//'   | # REMOVE TRAILING WHITESPACE
  #        md5sum | cut -c 1-10` # CREATE UNIQUE ID

    MOREOPTIONS=`echo $*               | # START PIPE
                 sed 's/OPTIONS:/\n&/' | #
                 grep "^OPTIONS:"      | #
                 head -n 1             | #
                 cut -d ":" -f 2`
    PPPDFS=`sed "1,${PPSEPNUM}d" $SRCDUMP  | # PRINT FROM LINENUM TO END
            grep -v "^% PP"                | # IGNORE COMMAND ITSELF
            sed "s/[ ]*${COMSTART}[ ]*//g" | #
            sed "s/[ ]*$COMCLOSE[ ]*//g"   | #
            sed "s/^[%]*[ ]*$/X.pdf/"      | # ALLOW EMPTY (=TO SHIFT)
            grep "\.pdf$"                  | # SELECT LINES WITH .pdf EXTENSION
            sed "s/^%//"                   | # REMOVE LEADING %
            sed "s/^[ ]*//"`                 # REMOVE ALL LEADING BLANKS
    PPNUM=`echo $PPPDFS |  sed 's/ /\n/g' | wc -l` # COUNT

     if [ "X$HREFMODE" != "XOFF"  ]; then
           PPLINK=`shortref $PPPDFS`
           echo $PPLINK
           REFCODE=`refsrc $PPLINK | sed 's/qrmargin/qroverlay/'`
       if [ "A$PPLINK" == "A$PPLBEFORE" ];then
           REFCODE=""
           echo "REF is the same"
       fi
           PPLBEFORE="$PPLINK"
     fi

   for PDFSRC in $PPPDFS
    do
       if [ "X$PDFSRC" == "XX.pdf" ]; then
             echo "do empty!"
             PPPAGES=$PPPAGES,
       else
        PDFGET=${TMPID}`echo $PDFSRC | md5sum | cut -c 1-8`.pdf

        if [ ! -f $PDFGET ]; then
              getFile $PDFSRC $PDFGET
            if [ -f $PDFGET ]; then
              pdfxgs $PDFGET
              PPPAGES=$PPPAGES,${PDFGET},-
            fi
        else
            #echo "no need to download"
             PPPAGES=$PPPAGES,$PDFGET,-
        fi
       fi
   done
          MKPN="pagecommand={\thispagestyle{fancy}\label{$REFID}$REFCODE},"
          OPTIONFILTER=`echo XX,$MOREOPTIONS | sed 's/,/\n/g' | #
                        cut -d "=" -f 1 | sed ':a;N;$!ba;s/\n/|/g' |#
                        sed 's/|$//' | sed 's/ //g'`
          PPPAGES=`echo $PPPAGES | sed 's/^,//'`

    if   [ $PPNUM -eq 1 ]; then

           PPPAGES=`echo $PPPAGES | sed "s/,-//g"`
          OPTIONS="nup=1x1,scale=.625,frame=true,
                   offset=28.5 27,$MKPN"
           PMACRO="\includepdf[$OPTIONS]{$PPPAGES}"

    elif [ $PPNUM -eq 2 ]; then

           OPTIONS="nup=1x2,frame=true,angle=\rotif,offset=28.5 27,
                    delta=10 10,scale=.637,$MKPN"
            PMACRO="\includepdfmerge[$OPTIONS]{$PPPAGES}"

    elif [ $PPNUM -eq 3 ]; then

           OPTIONS="nup=2x2,frame=true,offset=5 0,
                    delta=20 25,scale=.85,$MKPN"
            PMACRO="\includepdfmerge[$OPTIONS]{$PPPAGES}"

    elif [ $PPNUM -eq 4 ]; then

           OPTIONS="nup=2x2,frame=true,offset=28.5 30,
                    delta=10 10,scale=.61,$MKPN"
            PMACRO="\includepdfmerge[$OPTIONS]{$PPPAGES}"

    elif [ $PPNUM -eq 9 ]; then
 
           OPTIONS="nup=3x3,scale=1.97,frame=true,offset=29 27.5,
                    delta=10 10,$MKPN"
            PMACRO="\includepdfmerge[$OPTIONS]{$PPPAGES}"
    else
           OPTIONS=`echo "nup=4x4,frame=true,offset=28.5 30,
                    delta=10 10,scale=1.29,$MKPN" | #
                    sed 's/,/,\n/g' | #
                    egrep -v "$OPTIONFILTER"`",$MOREOPTIONS"
            PMACRO="\includepdfmerge[$OPTIONS]{$PPPAGES}"
    fi
       echo $PMACRO >> $SRCDUMP
)}

# --------------------------------------------------------------------------- #

function TEXIN() {
                          write2src "$*"
}
# KEEP FOR BACKWARDS COMPATIBILITY
function TEXINJECT() {
                          write2src "$*"
}

# --------------------------------------------------------------------------- #

function RESETALL() {
                          write2src "\resetall"
}

# --------------------------------------------------------------------------- #

function SCALEFONT() {
                          write2src "\relscale{$1}"
}

# --------------------------------------------------------------------------- #

function RESETFONT() {
                          write2src "\resetfont"
}

# --------------------------------------------------------------------------- #

function NEWPAGE(){
                          write2src "\newpage"
}

# --------------------------------------------------------------------------- #

function VFILL(){
                          write2src "\vfill"
}

# --------------------------------------------------------------------------- #

function BIGSKIP(){
                          write2src "\bigskip"
}

# --------------------------------------------------------------------------- #

function MEDSKIP(){
                          write2src "\medskip"
}

# --------------------------------------------------------------------------- #

function SMALLSKIP(){
                          write2src "\smallskip"
}

# --------------------------------------------------------------------------- #

function EMPTYPAGE(){
                          write2src "\emptypage"
}

# --------------------------------------------------------------------------- #

function CLEARTORIGHT(){
                          write2src "\cleartoright"
}

# --------------------------------------------------------------------------- #

function CLEARTOLEFT(){
                          write2src "\cleartoleft"
}

# --------------------------------------------------------------------------- #

function TITLE() {

  NBSPACE="N${RANDOM}B"

  echo -e "\n\n\n\n" >> $SRCDUMP
  echo "$*" | # KEEP (MULTIPLE) SPACES
  sed -e "s/\([a-zA-Z_*]\)\( \)\([a-zA-Z_*]\)/\1 $NBSPACE \3/g" | #
  pandoc -r markdown -w latex | #
  sed ':a;N;$!ba;s/\n/ /g'      | #      
  sed "s/[ ]*${NBSPACE}[ ]*/~/g"  | #
  sed 's/^/\\chapter{/' | sed 's/$/}/' >> $SRCDUMP
  write2src ""

}

# --------------------------------------------------------------------------- #

function FLUSHLOG(){

  write2src "\newpage"
  write2src "\begin{logfile}"
  write2src "\textbf{Network Activity:}"

  cat $WGETLOG              | #
  tr -d '\015'              | # CONVERT DOS END OF LINE (IN WGET -d MODE)
  tr -s ' '                 | # SQUEEZE CONSECUTIVE SPACES
  sed "s/-/{-}/g"           | #
  sed "s/_/\\\\_/g"         | #
  sed "s/%/\\\\%/g"         | #
  grep -v '\.\.\.\.\.\..*s$'| # IGNORE PROCESS LINES
  grep -v "^Saving"         | #
  grep -v " saved "         | #
  grep -v "^$"              | #
  sed "s/ /~/g"             | #
 #sed "s/ / \\\\hfill~/g"   | #
  sed "s/^/\\\\seqsplit{/g" | #
  sed "s/$/}/g"             | #
  tee                       >> $SRCDUMP

  write2src "\end{logfile}"
  write2src "\bigskip"

  rm $WGETLOG

}

# --------------------------------------------------------------------------- #

function FLUSHQRURLS(){

  write2src "\bigskip"
  write2src "URLS:"
  write2src ""

  for SHORTURL in `cat $QRURLLOG`
   do
     LONGURL=`curl -sIL $SHORTURL         | # CURL URL
              tr -d '\015'                | # CONFORM DOS END OF LINE
              grep ^Location              | # SELECT LOCATION
              cut -d ":" -f 2-            | # CUT SECOND FIELD
              tail -n 1                   | # SELECT LAST LINE
              sed 's,[ \t]*,,'            | # REMOVE ALL SPACES
              sed 's,/$,,'                | # REMOVE TRAILING SLASH
              sed "s,^${SHORTURLBASE}$,,"`  # DELETE SHORTURLBASE ONLY
     if [ `echo $LONGURL | wc -c` -ge 2 ]; then
           write2src "$SHORTURL -> $LONGURL"
      else
           write2src "$SHORTURL NOT SET!"
     fi
  done

}

# --------------------------------------------------------------------------- #

function INFO(){

  INFOID=`echo $1 | sed 's/ //g' | sed "s,$SHORTURLBASE/,,g"`

  IFHTTP=`echo $INFOID | grep "http.\?://" | wc -l`
  if [ $IFHTTP -ge 1 ]; then

       INFOSRC="$INFOID"
       INFOGET=${TMPID}`echo $INFOID | md5sum | cut -c 1-4`.info
       echo "NOT SHORTURLED: $INFOSRC"
  else
       SHORTURL="${SHORTURLBASE}/${INFOID}"
        LONGURL=`curl -sIL $SHORTURL         | # CURL URL
                 tr -d '\015'                | # CONFORM DOS END OF LINE
                 grep ^Location              | # SELECT LOCATION
                 cut -d ":" -f 2-            | # CUT SECOND FIELD
                 tail -n 1                   | # SELECT LAST LINE
                 sed 's,[ \t]*,,'            | # REMOVE ALL SPACES
                 sed 's,/$,,'                | # REMOVE TRAILING SLASH
                 sed "s,^${SHORTURLBASE}$,X,"` # DELETE SHORTURLBASE ONLY (-> PRODUCE 404)
       INFOSRC="${LONGURL}/info.txt"
       INFOGET=${TMPID}`echo $LONGURL | md5sum | cut -c 1-4`.info
  fi

  LHERE=L`echo $RANDOM | cut -c 1-3`N ; BHERE=B`echo $RANDOM | cut -c 1-3`R

  if [ ! -f $INFOGET ]; then
      getFile "$INFOSRC" "$INFOGET"
  else
     echo "No need to download!"
  fi

  if [ X$SUCCESS == XYES ]; then

     write2src "\marginpar{\begin{margininfo}"

     for SECTION in SHORT_INFO
    #for SECTION in SHORT_INFO LICENSE COPYRIGHT_HOLDER
      do
       SECTION=`echo $SECTION | sed 's/_/ /g'`
       cat $INFOGET                | # USELESS USE OF CAT
       sed "s/^%.*$//"             | # REPLACE COMMENTS WITH EMPTY LINE
       sed -e :a \
           -e '$!N;s/\n[ \t]*=/ /;ta' \
           -e 'P;D'                | # APPEND UNDERLINE TO PREVIOUS LINE
       sed -n "/${SECTION}[ \t]*=*$/,\$p" | # PRINT FROM REGEX TO END OF FILE
       sed "s/^[ \t]*$/$LHERE/g"   | # REMOVE EMPTY LINES
       sed "/=\?=$/s/^/\n/"        | # ADD NEWLINE AT START IF ENDS WITH ==
       sed  '1,/^$/!d'             | # FIRST PARAGRAPH ONLY
       grep -v "^[ \t]*$SECTION[ \t]*=*$" | # IGNORE SECTION LINES
       sed ':a;N;$!ba;s/\n/ /g'    | # REMOVE LINEBREAKS
       sed "s/$/$BHERE/"           | # PROTECT LINEBREAKS HERE
       pandoc -r markdown -w latex | # FROM MARKDOWN TO LATEX
       sed ':a;N;$!ba;s/\n/ /g'    | # REMOVE LINEBREAKS
       sed "s/$BHERE/\n/g"         | # RESTORE LINEBREAKS
       sed "s/$LHERE/ /g"          | # RESTORE EMPTY LINES
       sed 's/ /\n/g'              | #
       sed -e '/^http.\{20\}/s/^/\\urlsplit{/' \
           -e '/^\\urlsplit/s/$/}/'| #
       sed -e '/^http:\/\//s/^/\\urlf{/' \
           -e '/^\\urlf/s/$/}/'| #
       tee  >> $SRCDUMP              # WRITE TO FILE
       write2src ""                  # EMPTY LINE

     done
       write2src "\end{margininfo}\vspace{1cm}}"
  else
       echo "file does not exist"
  fi

}

# --------------------------------------------------------------------------- #

function TABLEOFCONTENTS(){

  write2src "\cleardoublepage"
  write2src "\setcounter{tocdepth}{0}"
  write2src "\tableofcontents"
  write2src "\newpage"
}

# --------------------------------------------------------------------------- #

function TOCITEM(){

  TOCTITLE=`echo $* | pandoc -r markdown -w latex`

  if [ `echo $TOCTITLE | grep ":" | wc -l` -gt 0 ]; then
  F1=`echo $TOCTITLE | cut -d ":" -f 1`
  F2=`echo $TOCTITLE | cut -d ":" -f 2-`
  TOCTITLE="\underline{\textsc{$F1}}: $F2"
  fi

  write2src "\addcontentsline{toc}{chapter}{$TOCTITLE}"

}

# --------------------------------------------------------------------------- #

function REF() {

  REFID=`echo $*             | # WHAT? 
         sed 's/^[ \t]*//'   | # REMOVE LEADING WHITESPACE
         sed 's/[ \t]*$//'   | # REMOVE TRAILING WHITESPACE
         md5sum | cut -c 1-10` # CREATE UNIQUE ID
          
  write2src "\label{$REFID}"

}

# --------------------------------------------------------------------------- #

function REFREF() {

  REFID=`echo $*             | # WHAT? 
         sed 's/^[ \t]*//'   | # REMOVE LEADING WHITESPACE
         sed 's/[ \t]*$//'   | # REMOVE TRAILING WHITESPACE
         md5sum | cut -c 1-10` # CREATE UNIQUE ID
          
  write2src "(\ding{222} p. \pageref{$REFID})"
}

# --------------------------------------------------------------------------- #

function BY(){

  write2src "{\by{$*}}"

}

# --------------------------------------------------------------------------- #

function LICENSE(){

  LICENSE=`echo $* | cut -d " " -f 1`
  VERSION=`echo $* | cut -d " " -f 2 | cut -d "(" -f 2 | cut -d ")" -f 1`

  LNAME=`echo $*           | #
         sed 's/[ ]*(/_/g' | #
         sed 's/)//g'      | #
         sed 's,[ ]*/[ ]*,_,g'`
  LID=`echo $LNAME | md5sum | cut -c 1-6`

  BADGESRC=EDIT/151025_licenses.svg
  BADGEPDF=${TMPID}${LID}`echo $RANDOM | cut -c 1-2`.pdf

# SELECT LAYERS: ONE FOR EACH UNIQUE NAME
# ---------------------------------------------------------------------------- #
  sed ":a;N;\$!ba;s/\n/ /g" $BADGESRC   | # REMOVE ALL LINEBREAKS
  sed 's/<g/\n<g/g'                     | # RESTORE GROUP OPEN + NEWLINE
  sed '/groupmode="layer"/s/<g/4Fgt7R/g'| # PLACEHOLDER FOR LAYERGROUP OPEN
  sed ':a;N;$!ba;s/\n/ /g'              | # REMOVE ALL LINEBREAKS
  sed 's/4Fgt7R/\n<g/g'                 | # RESTORE LAYERGROUP OPEN + NEWLINE
  sed 's/display:none/display:inline/g' | # MAKE VISIBLE EVEN WHEN HIDDEN
  tee head.tmp                          | # DUMP NOW TO EXTRACT HEAD LATER
  tail -n +2                            | # REMOVE HEAD (=FIRST LINE)
  sed 's/<\/svg>//g'                    | # REMOVE CLOSING TAG
  grep -n ""                            | # NUMBER LINES
  sed "s/^.*$/&|&/g"                    | # DOUBLE CONTENT FOR ANALYSIS
  sed "s/:label/\nX1X/"                 | # MARK LABEL (=NAME)
  grep -v ":label=\"XX_"                | # IGNORE XX LAYERS
  grep  "^X1X"                          | # SELECT MARKED
  egrep ":label=\"$LNAME|:label=\"DEKO" | #
  shuf                                  | # SHUFFLE
  sort -u -t\" -k1,2                    | # SELECT ONE FOR EACH LABEL
  cut -d "|" -f 2-                      | # SELECT SECOND/UNTOUCHED CONTEN
  sort -n -u -t: -k1,1                  | # SORT ACCORDING TO LINE NUMBER
  cut -d ":" -f 2-                      | # REMOVE LINENUMBER
  tee  > layers.tmp                       # WRITE TO FILE
# ---------------------------------------------------------------------------- #

  head -n 1 head.tmp  >  ${TMPID}ll.svg
  cat layers.tmp      >> ${TMPID}ll.svg
  echo '</svg>'       >> ${TMPID}ll.svg
  inkscape --export-pdf=$BADGEPDF \
           ${TMPID}ll.svg
  rm ${TMPID}ll.svg head.tmp layers.tmp

  LREF=""
  for L in `echo $* | #
            sed 's/[ ]*(/_/g' | #
            sed 's/)//g' | #
            sed 's,[ ]*/[ ]*,\n,g' | #
            sort -u`
   do
      LID=`echo $L | md5sum | cut -c 1-6`
      LREF="${LREF},\pageref{$LID}"
  done

  LREF=`echo $LREF | sed 's/^,//'`

  write2src "\qrmargin{$BADGEPDF}{0000}"
  write2src "\marginpar{\begin{marginlicenseblock}"
  write2src "{\relscale{.7}\ding{222}\relscale{1.2} p.${LREF}~}"
  write2src "\end{marginlicenseblock}\vspace{.8cm}}"

  echo $* | #
  sed 's/[ ]*(/_/g' | #
  sed 's/)//g' | #
  sed 's,[ ]*/[ ]*,\n,g' >> $TMPID.licenses

}

# --------------------------------------------------------------------------- #

function FLUSHLICENSES(){

   GITBASEURL="https://github.com/christop/licenses/raw"

 #      FAL_1.3:d31e37d/pdf/FAL_1.3.pdf
 #      GPL_2.0:07f63bc/pdf/GPL_2.0.pdf
 #      GPL_3.0:407d3a2/pdf/GPL_3.0.pdf
 #     GFDL_1.2:2f159f8/pdf/GFDL_1.2.pdf
 #     GFDL_1.3:8c8aeae/pdf/GFDL_1.3.pdf
 # CC-BY-SA_2.5:3cea07b/pdf/CC-BY-SA_2.5.pdf
 # CC-BY-SA_3.0:362006e/pdf/CC-BY-SA_3.0.pdf

    write2src "\emptypage"
    write2src "\cleartoright"

    for LNAME in `cat $TMPID.licenses | sort -u`
     do
        LPDFURL=$GITBASEURL/`grep $LNAME $FUNCTIONS | #
                             tail -n 1 | cut -d ":" -f 2-`
        LID=`echo $LNAME | md5sum | cut -c 1-6`
        OPTIONS=",scale=.9,offset=15 5"
        getFile $LPDFURL ${TMPID}${LID}.pdf
     if [ -f ${TMPID}${LID}.pdf ]; then
        write2src "\cleartoright"
        write2src "\pdfpageplus{${TMPID}${LID}.pdf}{1}{$OPTIONS}{\label{$LID}}"
     fi
   done
}

# --------------------------------------------------------------------------- #

function SWAP(){ 
 
  FROM=`echo $* | cut -d " " -f 1   | # 
        sed 's/ //g' | sed 's/"//g' | sed 's/\\\/\\\\\\\/g'` 
    TO=`echo $* | cut -d " " -f 2   | # 
        sed 's/ //g' | sed 's/"//g' | sed 's/\\\/\\\\\\\/g'` 
   
   sed -i "s/\b$FROM\b/$TO/g" ${SRCDUMP}
}

# --------------------------------------------------------------------------- #



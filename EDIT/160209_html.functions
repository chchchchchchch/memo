# =========================================================================== #
#  O V E R W R I T E   F U N C T I O N S
# =========================================================================== #

# ...



# =========================================================================== #
#  S H A R E D
# =========================================================================== #
  SHORTURLBASE="http://lfkn.de"
  REPOURL="http://gitlab.com/christophh/pppp/tree/master"
  XLINKID="xlink:href"
  SRCLIST=${TMPID}X.list
  MDSHALL="EDIT/160203_all.list"


# =========================================================================== #

 function listSrc() {

  if [ `echo $* | wc -c` -lt 2 ]; then   # = NO PARAMETERS PROVIDED 
       SEP="% ------------"              # THIS IS THE SEPARATOR
      SEPN=`grep -n "" $SRCDUMP             | # NUMBER LINES
            egrep "$SEP|^[0-9]*:$EMPTYLINE" | # LOCATE SEPARATOR OR EMPTY LINE
            tail -n 1                       | # SELECT LAST 
            cut -d ":" -f 1`                  # SELECT FIRST FIELD
       sed "1,${SEPN}d" $SRCDUMP   | # PRINT FROM LINE NUM TO END
       grep -v "^% QUAVERBATIM"    | # IGNORE COMMAND ITSELF
       sed "s/^%//"                | # REMOVE LEADING %
       sed "s/^[ ]*//"             | # REMOVE ALL LEADING BLANKS
       sed "/^[ \t]*$/d"           | # REMOVE EMPTY LINES
       tee      > $SRCLIST
  else 
       echo $*  > $SRCLIST
  fi

 }

# =========================================================================== #

 function getFileRange() {
 
   COLLECTED=$TMPID.srccollected
 
 ( IFS=$'\n'

  if [ -f $SRCLIST ]; then
   for THISSRC in `cat $SRCLIST`
    do
       SRCURL=`echo $THISSRC | sed 's/ /\n/g'   | # SPACES TO NEWLINES
               sed "/\.functions$/s/^/XXX/g"    | # MARK LINES WITH .functions EXTENSION
               sed "/\.[a-z]\{2,4\}$/s/^/XXX/g" | # MARK LINES WITH 2-4 CHAR EXT
               grep "^XXX" | sed 's/^XXX//'     | # SELECT AND REMOVE MARK
               head -n 1`                         # SELECT FIRST
        LINES=`echo $THISSRC | sed "s/ /\n/g"   | # SPACES TO NEWLINES
               sed "/[^0-9\\-]/d"               | # NO LINES WITH MORE THAN NUMS AND -
               egrep -v "^-|-$"                 | # IGNORE ISOLATED - 
               grep -v "^[ ]*$" | tail -n 1`      # LAST LINE ONLY
       if [ `echo $LINES | wc -c` -gt 1 ]; then   # IF LINE OPTION IS SET
             LINES=`echo $LINES | sed 's/-/,/'`
             SELECTSRCLINES="sed -n \"${LINES}p\" "
       else                                       # IF LINE OPTION IS NOT SET
             SELECTSRCLINES="tee"
       fi
       SRCGET=${TMPID}SRC`echo $SRCURL | md5sum | cut -c 1-3`.txt  
       if [ ! -f $SRCGET ]; then
            getFile $SRCURL $SRCGET
       fi;  if [ -f $SRCGET ]; then
            cat   $SRCGET                 | # START WITH ALL
            eval "$SELECTSRCLINES"        | # DO SELECT LINE RANGE
            tee                           >> $COLLECTED
     fi
   done 
  fi
 )
   if [ -f $COLLECTED ]; then
   INDENT=`cat $COLLECTED        | # START PIPE WITH COLLECTION
           sed '/^[ \t]*$/d'     | # IGNORE/DELETE EMPTY LINES
           sed -E 's/([^ ]).*//' | # KEEP ONLY LEADING BLANK
           sort -r               | # REVERSE SORT
           tail -n 1             | # SELECT LAST (=SHORTEST)
           wc -c`                  # COUNT  
   if [ $INDENT -eq 0 ]; then INDENT=1 ; fi
   fi
 }

# =========================================================================== #

 function conformColor() {

       sleep 0

  }

# =========================================================================== #

 function injectSRChref() {

      SRCSRC=$1

      IFHTTP=`echo $SRCSRC | grep "http.\?://" | wc -l`
      if [ $IFHTTP -lt 1 ]; then

           SRCHREF="$REPOURL/$SRCSRC"

      else
           SRCHREF="$SRCSRC"
      fi

      write2src "<div class=\"sref\"><a href=\"$SRCHREF\">
                 <img src=\"../../../lib/img/qrwww.svg\" /></a></div>"
 }

# =========================================================================== #

  function svglayers2pdfpages() {

   CROP=10.63 # 3mm in px

     SVGLAYER=$1
     PDFPAGES=$2
     SUPERTMP=${TMPID}.`echo $SVGL | md5sum | cut -c 1-4`.tmp
 
     CANVASWIDTH=`sed ":a;N;\$!ba;s/\n//g" $SVGLAYER | # SVG WITHOUT LINEBREAKS
                  sed 's/width=/\n&/g'               | # EXTRACT WIDTH
                  grep "^width="                     | # EXTRACT WIDTH
                  cut -d "\"" -f 2                   | # EXTRACT WIDTH VALUE
                  head -n 1`                           # FIRST WIDTH ONLY
      LAYERNAMES=`sed ":a;N;\$!ba;s/\n//g" $SVGLAYER | # SVG WITHOUT LINEBREAKS
                  sed 's/nkscape:label/\n&/g'        | # EXTRACT LAYER NAME
                  grep "^nkscape:label"              | # EXTRACT LAYER NAME
                  cut -d "\"" -f 2                   | # EXTRACT LAYER NAME
                  grep -v XX_                        | # IGNORE XX_LAYERS
                  sort -u`                             # SORT AND UNIQ
 
     BFOO=NL`echo ${RANDOM} | cut -c 1`F00
     SFOO=SP`echo ${RANDOM} | cut -c 1`F0O
   # ----------------------------------------------------------------------- #
   # MOVE LAYERS ON SEPARATE LINES (TEMPORARILY; EASIFY PARSING LATER ON)
   # ----------------------------------------------------------------------- #
     sed ":a;N;\$!ba;s/\n/$BFOO/g" $SVGLAYER | # REMOVE ALL LINEBREAKS (BUT SAVE)
     sed "s/ /$SFOO/g"                       | # REMOVE ALL SPACE (BUT SAVE)
     sed 's/<g/4Fgt7RfjIoPg7/g'              | # PLACEHOLDER FOR GROUP OPEN
     sed ':a;N;$!ba;s/\n/ /g'                | # REMOVE ALL NEW LINES
     sed 's/4Fgt7RfjIoPg7/\n<g/g'            | # RESTORE GROUP OPEN + NEWLINE
     sed '/groupmode="layer"/s/<g/4Fgt7R/g'  | # PLACEHOLDER FOR LAYERGROUP OPEN
     sed ':a;N;$!ba;s/\n/ /g'                | # REMOVE ALL LINEBREAKS
     sed 's/4Fgt7R/\n<g/g'                   | # RESTORE LAYERGROUP OPEN + NEWLINE
     sed 's/<\/svg>//g'                      | # REMOVE SVG CLOSE
     sed 's/display:none/display:inline/g'   | # MAKE VISIBLE EVEN WHEN HIDDEN
     tee > ${SUPERTMP}                         # WRITE TO TEMPORARY FILE
   # ----------------------------------------------------------------------- #
   # WRITE LAYERS TO SEPARATE FILES AND TRANSFORM TO PDF 
   # ----------------------------------------------------------------------- #
     COUNT=1 
     for LAYERNAME in $LAYERNAMES
      do
         for PAGE in 1 2
          do
             if [ $PAGE -eq 1 ]; then
                  XSHIFT=-$CROP
             else
                  XSHIFT=-`python -c "print $CANVASWIDTH - $CROP"`
             fi
             TRANSFORM="transform=\"translate($XSHIFT,0)\""
             NUM=`echo 0000$COUNT | rev | cut -c 1-4 | rev`
             LNAME=`echo $LAYERNAME | md5sum | cut -c 1-6`

                head -n 1 ${SUPERTMP}  | # THE HEADER
                sed "s/$BFOO/\n/g"     | # RESTORE ORIGINAL LINEBREAKS
                sed "s/$SFOO/ /g"      | # RESTORE ORIGINAL SPACES
                tee                    >   ${TMPID}_${NUM}_${LNAME}.svg
                echo "<g $TRANSFORM>"  >>  ${TMPID}_${NUM}_${LNAME}.svg
                grep "inkscape:label=\"$LAYERNAME\"" ${SUPERTMP} | #
                sed "s/$BFOO/\n/g"     | # RESTORE ORIGINAL LINEBREAKS
                sed "s/$SFOO/ /g"      | # RESTORE ORIGINAL SPACES
                tee                    >>  ${TMPID}_${NUM}_${LNAME}.svg
                echo "</g>"            >>  ${TMPID}_${NUM}_${LNAME}.svg
                echo "</svg>"          >>  ${TMPID}_${NUM}_${LNAME}.svg 
    
                inkscape --export-pdf=${TMPID}_${NUM}_${LNAME}.pdf \
                         --export-text-to-path \
                         ${TMPID}_${NUM}_${LNAME}.svg
   
                conformColor ${TMPID}_${NUM}_${LNAME}.pdf

                rm ${TMPID}_${NUM}_${LNAME}.svg

             COUNT=`expr $COUNT + 1`
          done
     done
   # ----------------------------------------------------------------------- #
   # MAKE MULTIPAGE PDF
   # ----------------------------------------------------------------------- #
     pdftk ${TMPID}_*.pdf cat output $PDFPAGES
   # ----------------------------------------------------------------------- #
   # CLEAN UP(OBSOLETE?)
   # ----------------------------------------------------------------------- #
     rm ${TMPID}_*.pdf $SVGLAYER
 
  }


# =========================================================================== #

 function mkpages() {

 # TODO: check if pages exists -> ~ adjust

   FIRSTPAGEIS="" # RESET
 
   PDFSRC=`echo $* | sed 's/ /\n/g'    | # SPACES TO NEWLINES
           egrep "\.svg$|\.pdf$"       | # SELECT ENDING WITH .svg/.pdf
           head -n 1`                    # SELECT FIRST
    PAGES=`echo $* | sed 's/ /\n/g'    | # SPACES TO NEWLINES
           sed "/[^0-9\\-]/d"          | # NO LINES WITH MORE THAN NUMS AND -
           egrep -v "^-|-$"            | # IGNORE ISOLATED - 
           grep -v "^[ ]*$" | tail -n 1` # 
      EXT=`echo $PDFSRC | rev | cut -d "." -f 1 | rev`
 
   if [ `echo $PAGES | wc -c` -le 1 ]; then
         PAGES=-
   elif [ `echo $PAGES | grep "^[0-9]" | wc -l` -ge 1 ]; then
         P1=`echo $PAGES | cut -d "-" -f 1`
         if [ `python -c "print $P1 / 2.0" | #
               cut -d "." -f 2` -lt 5 ]; then
               FIRSTPAGEIS="even"
         else
               FIRSTPAGEIS="odd"
         fi
   else
         PAGES=- ; PAGECOMMAND=""
   fi
 
   PDFGET=${TMPID}`echo $PDFSRC | md5sum | cut -c 1-4`.pdf
   SVGTMP=${TMPID}`echo $PDFSRC | md5sum | cut -c 5-9`.svg
 
   if [ -f $PDFGET ]; then
        echo "$PDFGET exists"
   else 
        if [ "X$EXT" == "Xsvg" ]; then
    
              getFile $PDFSRC $SVGTMP
    
        if [ "X$SUCCESS" == "XYES" ]; then

           SVGTMP=`realpath $SVGTMP`

        # ------------------------------------------------ #
        # MAKE IMAGE HREFS ABSOLUTE
        # ------------------------------------------------ #
    
        # TODO: if image does not exist -> substitute
 
          IFHTTP=`echo $PDFSRC | grep "http.\?://" | wc -l`
          if [ $IFHTTP -lt 1 ]; then
          SRCPATH=`realpath $PDFSRC | rev | #
                   cut -d "/" -f 2- | rev`
          SRCSRC=`basename $PDFSRC`
          cd $SRCPATH
            for XLINK in `cat $SRCSRC            | #
                          sed "s/$XLINKID/\n&/g" | #
                          grep "$XLINKID"`         #
             do
               IMGSRC=`echo $XLINK         | #
                       cut -d "\"" -f 2    | #
                       cut -d "\"" -f 2    | #
                       sed "s/$XLINKID//g" | #
                       sed 's,file://,,g'`   #
               IMG=`basename $IMGSRC`
               IMGPATH=`realpath $IMGSRC | rev | # 
                        cut -d "/" -f 2- | rev`  #
               ABSPATH=`realpath $IMGPATH`
               NEWXLINK="$XLINKID=\"$ABSPATH/$IMG\""
               sed -i "s,$XLINK,$NEWXLINK,g" $SVGTMP
               echo "$XLINK -> $NEWXLINK"
            done
          cd - > /dev/null
         fi
              svglayers2pdfpages $SVGTMP $PDFGET
        fi
    
        elif [ "X$EXT" == "Xpdf" ]; then
    
               getFile $PDFSRC $PDFGET   
               conformColor $PDFGET
        fi
   fi
 }

# =========================================================================== #
# =========================================================================== #



# --------------------------------------------------------------------------- #

function QUAVERBATIM() {

  listSrc $*
  getFileRange

  if [ -f $COLLECTED ]; then

    #if [ X"$QRMODE" != XOFF  ]; then
    # mkqr $*
    # write2src "$QRHREF"
    #fi

    injectSRChref $THISSRC
  # ------------------------------------------------------------------------- #
    write2src "<pre class=\"quaverbatim\">"

     cat $COLLECTED      | # START ...
     cut -c ${INDENT}-   | # REMOVE INDENT
     sed 's/</\&lt;/g'   | # ENTITY FOR BRACKET
     sed 's/>/\&gt;/g'   | # ENTITY FOR BRACKET
     tee >> $SRCDUMP       # WRITE TO FILE

    write2src "</pre>"
  # ------------------------------------------------------------------------- #

  rm $COLLECTED

  fi

  if [ -f $SRCLIST ]; then rm $SRCLIST ;fi

}

# --------------------------------------------------------------------------- #

function SRCODE() {

  listSrc $*
  getFileRange

  if [ -f $COLLECTED ]; then


       SRCURL=`echo $* | sed 's/ /\n/g'         | # SPACES TO NEWLINES
               sed "/\.functions$/s/^/XXX/g"    | # MARK LINES WITH .functions EXTENSION
               sed "/\.[a-z]\{2,4\}$/s/^/XXX/g" | # MARK LINES WITH 2-4 CHAR EXT
               grep "^XXX" | sed 's/^XXX//'     | # SELECT AND REMOVE MARK
               head -n 1`                         # SELECT FIRST


      injectSRChref $SRCURL

  # ------------------------------------------------------------------------- #
    write2src "<pre>"

     cat $COLLECTED      | # START ...
     cut -c ${INDENT}-   | # REMOVE INDENT
     sed 's/</\&lt;/g'   | # ENTITY FOR BRACKET
     sed 's/>/\&gt;/g'   | # ENTITY FOR BRACKET
     tee >> $SRCDUMP       # WRITE TO FILE

    write2src "</pre>"
  # ------------------------------------------------------------------------- #

  rm $COLLECTED

  fi

  if [ -f $SRCLIST ]; then rm $SRCLIST ;fi

}

# --------------------------------------------------------------------------- #

function HTMLIN() {

 # 1: HTMLIN: input.html 1-2
 # 2: HTMLIN: <img src="http://www.image.de/image.jpg" />
 # 3:
 # % --------------------------------
 # % <table><tr><td>
 # % <img src="http://www.image.de/image.jpg" />
 # % </td></tr></table>
 # % HTMLIN:

  listSrc $*

  if [ -f $SRCLIST ]; then

 ( IFS=$'\n'
   for ITEM in `cat $SRCLIST`
    do

      if [ `echo $ITEM         | #
            sed 's/ /\n/g'     | #
            grep "\.htm[l]\?$" | #
            wc -l` -lt 1 ]; then
            write2src "$ITEM"
       else

        echo "$ITEM"
        HTMURL=`echo $ITEM  | sed 's/ /\n/g'    | # SPACES TO NEWLINES
                sed "/\.htm[l]\?$/s/^/XXX/g"    | # MARK LINES WITH .htm(l) EXT
                grep "^XXX" | sed 's/^XXX//'    | # SELECT AND REMOVE MARK
                head -n 1`                        # SELECT FIRST
         LINES=`echo $ITEM | sed "s/ /\n/g"     | # SPACES TO NEWLINES
                sed "/[^0-9\\-]/d"              | # NO LINES WITH MORE THAN NUMS AND -
                egrep -v "^-|-$"                | # IGNORE ISOLATED - 
                tail -n 1`                        # LAST LINE ONLY
         if [ `echo $LINES | wc -c` -gt 1 ]; then # IF LINE OPTION IS SET
               LINES=`echo $LINES | sed 's/-/,/'`
               SELECTSRCLINES="sed -n \"${LINES}p\" "
         else                                       # IF LINE OPTION IS NOT SET
               SELECTSRCLINES="tee"
         fi
         HTMGET=${TMPID}SRC`echo $HTMURL | md5sum | cut -c 1-3`.txt
         if [ ! -f $HTMGET ]; then
              getFile $HTMURL $HTMGET
         fi;  if [ -f $HTMGET ]; then
              cat   $HTMGET                 | # START WITH ALL
              eval "$SELECTSRCLINES"        | # DO SELECT LINE RANGE
              tee                           >> $SRCDUMP
         fi
      fi

   done )

   rm $SRCLIST
   fi

}

# --------------------------------------------------------------------------- #

function SPREAD() {

   mkpages $*

   EXPORTBASE=`echo $PDFSRC | md5sum | cut -c 1-10`
   if [ `ls ${TMPID}${EXPORTBASE}_[0-9]*.png 2> /dev/null | #
         wc -l` -lt  1 ]; then
         convert $PDFGET ${TMPID}${EXPORTBASE}_%05d.png  
   fi

   if [ `echo $PAGES | grep "^-$" | wc -l` -gt 0 ]; then
         PA="1"
         PX=`pdftk $PDFGET dump_data output | #
             grep -i NumberofPages | cut -d ":" -f 2 | #
             sed 's/ //g'`
         PAGES="${PA}-${PX}"
         echo $PAGES
   fi

   PA=`echo $PAGES | cut -d "-" -f 1`
   PX=`echo $PAGES | cut -d "-" -f 2`
   REGION="-crop 417x592+10+10 +repage"

   injectSRChref $PDFSRC

   CNT=1 ; PN=$PA # KEEP ON COUNTING
   for PAGESELECTION in `ls ${TMPID}${EXPORTBASE}_[0-9]*.png | #
                         sed -n "${PA},${PX}p"`
     do
        PAIR="$PAIR \( $PAGESELECTION $REGION -flatten -coalesce -append \)"
        CNT=`expr $CNT + 1`
        if [ $CNT -gt 2 ]; then

            EXPORTNUM="${PN}-$((PN + 1))"
            EXPORTNAME="${EXPORTBASE}_${EXPORTNUM}.png"
            EXPORTFULL=$HTMLSRCDIR/${EXPORTNAME}
            eval "convert $PAIR +append \
                                -gravity west ${EXPORTFULL}"

            IMGPFAD="$HTMLSRCDIRNAME/$EXPORTNAME"
            write2src "<img src=\"$IMGPFAD\" class=\"spread full\" />"

            PAIR=""; CNT=1 # RESET
            PN=`expr $PN + 1`
        fi
    done
            if [ `echo $PAIR | wc -c` -gt 1 ]; then
            EXPORTNAME="${EXPORTBASE}_${PX}-X.png"
            EXPORTFULL=$HTMLSRCDIR/$EXPORTNAME
            eval "convert $PAIR +append \
                                -gravity west ${EXPORTFULL}"

            IMGPFAD="$HTMLSRCDIRNAME/$EXPORTNAME"
            write2src "<img src=\"$IMGPFAD\" class=\"spread half\" />"

            fi
            PAIR="" # RESET

}

# --------------------------------------------------------------------------- #

function PDF() {

  listSrc $*

 ( IFS=$'\n'
  for ITEM in `cat $SRCLIST`
   do
      PDFSRC=`echo $ITEM | sed 's/ /\n/g'  | # SPACES TO NEWLINES
              grep "\.pdf$" | head -n 1`     # SELECT FIRST ENDING WITH .pdf 
       PAGES=`echo $ITEM | sed "s/#/\n#/g" | # HASH TO NEWLINES
              grep -v "^#"                 | # IGNORE HASH LINES
              sed 's/ /\n/g'               | # SPACES TO NEWLINES
              sed "/[^0-9\\-]/d"           | # NO LINES WITH MORE THAN NUMS AND -
              egrep -v "^-|-$"             | # IGNORE ISOLATED - 
              grep -v "^[ ]*$" | tail -n 1`  # NO EMPTY / LAST LINE ONLY

      if [ `echo $PAGES | wc -c` -le 1 ]; then
            PAGES=-
      fi
      OPTIONS=`echo $ITEM | sed "s/#/\n#/g"       | #
               grep "^#" | tail -n 1              | #
               cut -d "#" -f 2 | sed 's/^[ \t]*//'` # 
      if [ `echo $OPTIONS | wc -c` -gt 1 ]; then
            OPTIONS=",$OPTIONS"
      fi

   PDFGET=${TMPID}`echo $PDFSRC | md5sum | cut -c 1-4`.pdf
   if [ ! -f $PDFGET ]; then
         getFile $PDFSRC $PDFGET
   fi
   if [ -f $PDFGET ]; then

         EXPORTBASE=`echo $PDFSRC | md5sum | cut -c 1-10`

         convert $PDFGET ${TMPID}${EXPORTBASE}_%05d.png  
        
      if [ `echo $PAGES | grep "^-$" | wc -l` -gt 0 ]; then
            PA="1"
            PX=`pdftk $PDFGET dump_data output | #
                grep -i NumberofPages | cut -d ":" -f 2 | #
                sed 's/ //g'`
            PAGES="${PA}-${PX}"
            echo $PAGES
      fi
      PA=`echo $PAGES | cut -d "-" -f 1`
      PX=`echo $PAGES | cut -d "-" -f 2`

   PN=$PA

  #injectSRChref $PDFSRC

   for THISPAGE in `ls ${TMPID}${EXPORTBASE}_[0-9]*.png | #
                    sed -n "${PA},${PX}p"`
     do
            EXPORTNUM="${PN}-$((PN + 1))"
            EXPORTNAME="${EXPORTBASE}_${EXPORTNUM}.png"
            EXPORTFULL=$HTMLSRCDIR/${EXPORTNAME}
            convert $THISPAGE -flatten $EXPORTFULL
            IMGPFAD="$HTMLSRCDIRNAME/$EXPORTNAME"
            write2src "<img src=\"$IMGPFAD\" class=\"pdf\" />"
            PN=`expr $PN + 1`
    done

   fi

  done )

  if [ -f $SRCLIST ]; then rm $SRCLIST ;fi

}

# --------------------------------------------------------------------------- #










































# --------------------------------------------------------------------------- #

function SHOWASAP() {

   mkpages $*
   REF=`echo $RANDOM | md5sum | cut -c 1-9`

   MACRO="% something went wrong with $SVGSRC"

   if [ `echo $PAGES | sed '/^[0-9]/!d' | wc -l` -gt 0 ]; then
         P=`echo $PAGES | cut -d "-" -f 1`
   else
         P=1
   fi

   if [ -f $PDFGET ]; then
      MACRO="\fullpagefloat{$PDFGET}{$P}{$REF}"
   fi

   write2src "$MACRO"
}

# --------------------------------------------------------------------------- #


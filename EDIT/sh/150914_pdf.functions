# --------------------------------------------------------------------------- #
# S H A R E D
# --------------------------------------------------------------------------- #
  SHORTURLBASE="http://lfkn.de"



# --------------------------------------------------------------------------- #





# --------------------------------------------------------------------------- #

function INCLUDE() {

# TODOTODO: check, check, debug
# mdsh2src $PARAMETERSWITHOUTFUNCTIONS # TODOTODO

  echo "INCLUDE STARTS ====================================================="

# EXTRACT OPTIONAL PARAMETERS
# ---------------------------------------------------------
  FUNCTIONSHERE=`echo $* | sed 's/ /\n/g' | #
                 grep "\.functions$" | tail -n 1`

  if [ `echo $FUNCTIONSHERE | wc -c` -gt 1 ];then
  PARAMETERSWITHOUTFUNCTIONS=`echo $*        | #
                              sed 's/ /\n/g' | #
                              grep -v "\.functions$"`                                    # TODO: BETTER

# ATTACH FUNCTIONS TO MAIN FUNCTIONS
# ---------------------------------------------------------
  if [ `ls $FUNCTIONSHERE 2>/dev/null | wc -l` -gt 0 ];then

   FID=`date +%s%N`
 # ATTACH AND MARK FUNCTIONS
   echo "#  -- ${FID} -- START" >> $FUNCTIONS
   cat  $FUNCTIONSHERE          >> $FUNCTIONS
   echo "#  -- ${FID} -- END"   >> $FUNCTIONS
   FUNCTIONSADDED="YES"
 # SAVE FUNCTION ID (AS VARIABLE MAY BE OVERWRITTEN)
   echo $FID >> ${TMPID}.fid
   fi
   else
   FUNCTIONSADDED="NO"
  fi

# MAKE QR REFERENCE
# --------------------------------------------------------
  mkqr $*
  write2src "HERE$QRID"

# PROCESS INPUT !!!!!
# --------------------------------------------------------
  mdsh2src $*

# ADD REFERENCE IF NOT SKIPPED
# --------------------------------------------------------
  if [ X"$SKIP"   != XYES ] &&
     [ X"$QRMODE" != XOFF  ]; then
       sed -i "s,HERE$QRID,\\\qrmargin{$QRPDF}{$QRTXT}," \
               $SRCDUMP
  else
        sed -i "s,HERE$QRID,,g" $SRCDUMP
  fi

# REMOVE ADDED FUNCTIONS
# --------------------------------------------------------
  if [ -f ${TMPID}.fid ]; then

# LOAD LATEST FUNCTION ID
  FID=`tail -n 1 ${TMPID}.fid`
# REMOVE FROM FUNCTIONS
  sed -i "/${FID} -- START$/,/${FID} -- END$/d" ${FUNCTIONS}
# REMOVE FROM SAVED FUNCTIONS
  sed -i "/$FID/d" ${TMPID}.fid
# RELOAD FUNCTIONS
  source $FUNCTIONS
  
  fi
  
  echo "INCLUDE ENDS  ======================================================"
}












# --------------------------------------------------------------------------- #

function SRC() {

 #write2src "link: $*"
 #echo "link: $*"
  sleep 0 
 
}

# --------------------------------------------------------------------------- #
# INJECT WHATEVER

function INJECT() {

   write2src "$*"

}
# --------------------------------------------------------------------------- #
# INJECT TEX CODE

function TEXINJECT() {

   write2src "$*"

}

# --------------------------------------------------------------------------- #
# CREATE AND INSERT PAGE SPREAD (SPECIFIC SRC)

function SPREAD() {

  CROP=10.63 # 3mm in px

  SVGSRC=$1
  SVGTMP=${TMPID}`echo $SVGSRC | md5sum | cut -c 1-4`.svg
     PDF=${TMPID}`echo $SVGSRC | md5sum | cut -c 1-4`.pdf

  SPRTMP=$TMPID.`echo $SVGTMP | md5sum | cut -c 1-4`.tmp

  ISSVG=`echo $SVGSRC | grep "\.svg$" | wc -l`
  if [ $ISSVG -gt 0 ]; then

    getFile $SVGSRC $SVGTMP
    echo $PDF

    if [ "X$SUCCESS" == "XYES" ]; then

    CANVASWIDTH=`sed ":a;N;\$!ba;s/\n//g" $SVGTMP | # SVG WITHOUT LINEBREAKS
                 sed 's/width=/\n&/g'             | # EXTRACT WIDTH
                 grep "^width="                   | # EXTRACT WIDTH
                 cut -d "\"" -f 2                 | # EXTRACT WIDTH VALUE
                 head -n 1`                         # FIRST WIDTH ONLY
    LAYERNAMES=`sed ":a;N;\$!ba;s/\n//g" $SVGTMP  | # SVG WITHOUT LINEBREAKS
                sed 's/nkscape:label/\n&/g'       | # EXTRACT LAYER NAME
                grep "^nkscape:label"             | # EXTRACT LAYER NAME
                cut -d "\"" -f 2                  | # EXTRACT LAYER NAME
                grep -v XX_                       | # IGNORE XX_LAYERS
                sort -u`                            # SORT AND UNIQ

    BFOO=NL`echo ${RANDOM} | cut -c 1`F00
    SFOO=SP`echo ${RANDOM} | cut -c 1`F0O
  # ----------------------------------------------------------------------- #
  # MOVE LAYERS ON SEPARATE LINES (TEMPORARILY; EASIFY PARSING LATER ON)
  # ----------------------------------------------------------------------- #
    sed ":a;N;\$!ba;s/\n/$BFOO/g" $SVGTMP | # REMOVE ALL LINEBREAKS (BUT SAVE)
    sed "s/ /$SFOO/g"                     | # REMOVE ALL SPACE (BUT SAVE)
    sed 's/<g/4Fgt7RfjIoPg7/g'            | # PLACEHOLDER FOR GROUP OPEN
    sed ':a;N;$!ba;s/\n/ /g'              | # REMOVE ALL NEW LINES
    sed 's/4Fgt7RfjIoPg7/\n<g/g'          | # RESTORE GROUP OPEN + NEWLINE
    sed '/groupmode="layer"/s/<g/4Fgt7R/g'| # PLACEHOLDER FOR LAYERGROUP OPEN
    sed ':a;N;$!ba;s/\n/ /g'              | # REMOVE ALL LINEBREAKS
    sed 's/4Fgt7R/\n<g/g'                 | # RESTORE LAYERGROUP OPEN + NEWLINE
    sed 's/<\/svg>//g'                    | # REMOVE SVG CLOSE
    sed 's/display:none/display:inline/g' | # MAKE VISIBLE EVEN WHEN HIDDEN
    tee > ${SPRTMP}                         # WRITE TO TEMPORARY FILE
  # ----------------------------------------------------------------------- #
  # WRITE LAYERS TO SEPARATE FILES AND TRANSFORM TO PDF 
  # ----------------------------------------------------------------------- #
    COUNT=1 
    for LAYERNAME in $LAYERNAMES
     do
        for PAGE in 1 2
        do
            if [ $PAGE -eq 1 ]; then
                 XSHIFT=-$CROP
            else
                 XSHIFT=-`python -c "print $CANVASWIDTH - $CROP"`
            fi
            TRANSFORM="transform=\"translate($XSHIFT,0)\""
            NUM=`echo 0000$COUNT | rev | cut -c 1-4 | rev`
            LNAME=`echo $LAYERNAME | md5sum | cut -c 1-6`
            head -n 1 ${SPRTMP}    | # THE HEADER
            sed "s/$BFOO/\n/g"     | # RESTORE ORIGINAL LINEBREAKS
            sed "s/$SFOO/ /g"      | # RESTORE ORIGINAL SPACES
            tee                    >   ${TMPID}_${NUM}_${LNAME}.svg
            echo "<g $TRANSFORM>"  >>  ${TMPID}_${NUM}_${LNAME}.svg
            grep "inkscape:label=\"$LAYERNAME\"" ${SPRTMP} | #
            sed "s/$BFOO/\n/g"     | # RESTORE ORIGINAL LINEBREAKS
            sed "s/$SFOO/ /g"      | # RESTORE ORIGINAL SPACES
            tee                    >>  ${TMPID}_${NUM}_${LNAME}.svg
            echo "</g>"            >>  ${TMPID}_${NUM}_${LNAME}.svg
            echo "</svg>"          >>  ${TMPID}_${NUM}_${LNAME}.svg

            inkscape --export-pdf=${TMPID}_${NUM}_${LNAME}.pdf \
                     --export-text-to-path \
                     ${TMPID}_${NUM}_${LNAME}.svg
            rm ${TMPID}_${NUM}_${LNAME}.svg
            COUNT=`expr $COUNT + 1`
        done
    done
  # ----------------------------------------------------------------------- #
  # MAKE MULTIPAGE PDF
  # ----------------------------------------------------------------------- #
    pdftk ${TMPID}_*.pdf cat output $PDF
  # ----------------------------------------------------------------------- #
  # CLEAN UP 
  # ----------------------------------------------------------------------- #
    rm ${SPRTMP} ${TMPID}_*.pdf $SVGTMP




    fi
  fi
}

# --------------------------------------------------------------------------- #

function TITLE() {

  write2src "";write2src ""
  echo $* | #
  pandoc -r markdown -w latex | #
  sed 's/^/\\\section{/' | sed 's/$/}/' >> $SRCDUMP
  write2src ""

}

# --------------------------------------------------------------------------- #

function SCALEFONT() {

  write2src "\relscale{$1}"

}

# --------------------------------------------------------------------------- #

function RESETFONT() {

  write2src "\resetfont"

}

# --------------------------------------------------------------------------- #

function PDF() {

  PDFSRC=`echo $* | sed 's/ /\n/g'    | # SPACES TO NEWLINES
          grep "\.pdf$" | head -n 1`    # SELECT FIRST ENDING WITH .pdf 
   PAGES=`echo $* | sed "s/#/\n#/g"   | # HASH TO NEWLINES
          grep -v "^#"                | # 
          sed 's/ /\n/g'              | #
          sed "/[^0-9\\-]/d"          | # NO LINES WITH MORE THAN NUMS AND -
          grep -v "^[ ]*$" | tail -n 1` # 
  if [ `echo $PAGES | wc -c` -le 1 ]; then
        PAGES=-
  fi
  OPTIONS=`echo $* | sed "s/#/\n#/g"          | #
           grep "^#" | tail -n 1              | #
           cut -d "#" -f 2 | sed 's/^[ \t]*//'` # 
  if [ `echo $OPTIONS | wc -c` -gt 1 ]; then
        OPTIONS=",$OPTIONS"
  else
        echo "no options provided"
  fi

  PDFGET=${TMPID}`echo $PDFSRC | md5sum | cut -c 1-4`.pdf
  if [ ! -f $PDFGET ]; then
        getFile $PDFSRC $PDFGET
      # TODO/MAYBE: MAKE PDF-X CONFORM
  else
     echo "no need to download"
    #sleep 2
  fi
  if [ -f $PDFGET ]; then
     if [ X"$QRMODE" != XOFF  ]; then
          mkqr $*
          write2src "\newpage"
          write2src "\qroverlay{$QRPDF}{$QRTXT}" 
     fi
         #write2src "\includepdf[scale=1,pages=$PAGES$OPTIONS]{$PDFGET}"
          write2src "\pdfpage{$PDFGET}{$PAGES}{$OPTIONS}"
  fi

}

# --------------------------------------------------------------------------- #

function SRCODE() {

  SRCSRC=`echo $* | sed 's/ /\n/g'         | # SPACES TO NEWLINES
          sed "/\.[a-z]\{2,4\}$/s/^/XXX/g" | # MARK LINES WITH 2-4 CHARACTER EXTENSION
          grep "^XXX" | sed 's/^XXX//'     | # SELECT AND REMOVE MARK
          head -n 1`                         # SELECT FIRST
   LINES=`echo $* | sed "s/ /\n/g" | # SPACES TO NEWLINES
          sed "/[^0-9\\-]/d"       | # NO LINES WITH MORE THAN NUMS AND -
          tail -n 1`                 # LAST LINE ONLY
  if [ `echo $LINES | wc -c` -gt 1 ]; then      # IF LINE OPTION IS SET
        echo "lines: $LINES"
        LINES=`echo $LINES | sed 's/-/,/'`
        SELECTSRCLINES="sed -n \"${LINES}p\" "
  else
        SELECTSRCLINES="tee"
  fi

  EXTENSION=`echo $SRCSRC | rev | cut -d "." -f 1 | rev`
  SRCGET=${TMPID}SRC`echo $SRCSRC | md5sum | cut -c 1-3`.$EXTENSION

  if [ ! -f $SRCGET ]; then
        getFile $SRCSRC $SRCGET
  else
     echo "no need to download"
    #sleep 2
  fi
  if [ -f $SRCGET ]; then

    if [ X"$QRMODE" != XOFF  ]; then
     mkqr $*
     write2src "\qrmargin{$QRPDF}{$QRTXT}"
    fi

    INDENT=`cat $SRCGET            | # DISPLAY SRC
            eval "$SELECTSRCLINES" | # SELECT LINES
            sed '/^[ \t]*$/g'      | # IGNORE EMPTY LINES
            sed -E 's/([^ ]).*//'  | # KEEP ONLY LEADING BLANK
            sort -r                | # REVERESE SORT
            tail -n 1              | # SELECT LAST (=SHORTEST)
            wc -c`                   # COUNT

     write2src "\begin{lstlisting}"
     cat $SRCGET            | #
     eval "$SELECTSRCLINES" | #
     cut -c ${INDENT}-      | #
     tee                    >> $SRCDUMP
     write2src "\end{lstlisting}"
  fi

}

# --------------------------------------------------------------------------- #

function QUAVERBATIM() {

 #LPRTCT="Y"
  SPRTCT=SP`echo $RANDOM | cut -c 1-4`CE
  BPRTCT=BR`echo $RANDOM | cut -c 1-4`AK


  TXTSRC=`echo $* | sed 's/ /\n/g'         | # SPACES TO NEWLINES
          sed "/\.[a-z]\{2,4\}$/s/^/XXX/g" | # MARK LINES WITH 2-4 CHARACTER EXTENSION
          grep "^XXX" | sed 's/^XXX//'     | # SELECT AND REMOVE MARK
          head -n 1`                         # SELECT FIRST
   LINES=`echo $* | sed "s/ /\n/g" | # SPACES TO NEWLINES
          sed "/[^0-9\\-]/d"       | # NO LINES WITH MORE THAN NUMS AND -
          tail -n 1`                 # LAST LINE ONLY
  if [ `echo $LINES | wc -c` -gt 1 ]; then      # IF LINE OPTION IS SET
        echo "lines: $LINES"
        LINES=`echo $LINES | sed 's/-/,/'`
        SELECTSRCLINES="sed -n \"${LINES}p\" "
  else
        SELECTSRCLINES="tee"
  fi

  TXTGET=${TMPID}SRC`echo $TXTSRC | md5sum | cut -c 1-3`.txt

  if [ ! -f $TXTGET ]; then
        getFile $TXTSRC $TXTGET
  else
     echo "no need to download"
  fi
  if [ -f $TXTGET ]; then

    if [ X"$QRMODE" != XOFF  ]; then
     mkqr $*
     write2src "\qrmargin{$QRPDF}{$QRTXT}"
    fi

     cat $TXTGET                     | #
     eval "$SELECTSRCLINES"          | #
     sed "s/ /$SPRTCT/g"             | #
    #sed "s/^[ \t]*$/$LPRTCT/g"      | #
     sed ":a;N;\$!ba;s/\n/$BPRTCT/g" | #
     tee                             > super.tmp

     write2src "\begin{alltt}"
     mdsh2src super.tmp
     write2src "\end{alltt}"

     sed -i "s/$BPRTCT/\n/g" $SRCDUMP
     sed -i "s/$SPRTCT/ /g" $SRCDUMP


  fi

}






# --------------------------------------------------------------------------- #

function NEWPAGE(){

  write2src "\newpage"
}

# --------------------------------------------------------------------------- #

function VFILL(){

  write2src "\vfill"
}

# --------------------------------------------------------------------------- #

function EMPTYPAGE(){

  write2src "\emptypage"
}

# --------------------------------------------------------------------------- #

function CLEARTORIGHT(){

  write2src "\cleartoright"
}

# --------------------------------------------------------------------------- #

function CLEARTOLEFT(){

  write2src "\cleartoleft"
}

# --------------------------------------------------------------------------- #

function FLUSHLOG(){

  write2src "\begin{logfile}"
  write2src "\textbf{Network Activity:}"

  cat $WGETLOG              | #
  tr -d '\015'              | # CONVERT DOS END OF LINE (IN WGET -d MODE)
  tr -s ' '                 | # SQUEEZE CONSECUTIVE SPACES
  sed "s/-/{-}/g"           | #
  sed "s/_/\\\\_/g"         | #
  sed "s/%/\\\\%/g"         | #
  grep -v '\.\.\.\.\.\..*s$'| # IGNORE PROCESS LINES
  grep -v "^Saving"         | #
  grep -v " saved "         | #
  grep -v "^$"              | #
  sed "s/ /~/g"             | #
 #sed "s/ / \\\\hfill~/g"   | #
  sed "s/^/\\\\seqsplit{/g" | #
  sed "s/$/}/g"             | #
  tee                       >> $SRCDUMP

  write2src "\end{logfile}"
  write2src "\bigskip"

  rm $WGETLOG

}

# --------------------------------------------------------------------------- #

function FLUSHQRURLS(){


  for SHORTURL in `cat $QRURLLOG`
   do
     LONGURL=`curl -sIL $SHORTURL         | # CURL URL
              tr -d '\015'                | # CONFORM DOS END OF LINE
              grep ^Location              | # SELECT LOCATION
              cut -d ":" -f 2-            | # CUT SECOND FIELD
              tail -n 1                   | # SELECT LAST LINE
              sed 's,[ \t]*,,'            | # REMOVE ALL SPACES
              sed 's,/$,,'                | # REMOVE TRAILING SLASH
              sed "s,^${SHORTURLBASE}$,,"`  # DELETE SHORTURLBASE ONLY
     if [ `echo $LONGURL | wc -c` -ge 2 ]; then
           echo "$SHORTURL -> $LONGURL"
      else
           echo "$SHORTURL NOT SET!"
     fi
  done

}




# --------------------------------------------------------------------------- #

function INFO(){

    REFCODE=$1
  SHORTURL="${SHORTURLBASE}/${REFCODE}"
   LONGURL=`curl -sIL $SHORTURL         | # CURL URL
            tr -d '\015'                | # CONFORM DOS END OF LINE
            grep ^Location              | # SELECT LOCATION
            cut -d ":" -f 2-            | # CUT SECOND FIELD
            tail -n 1                   | # SELECT LAST LINE
            sed 's,[ \t]*,,'            | # REMOVE ALL SPACES
            sed 's,/$,,'                | # REMOVE TRAILING SLASH
            sed "s,^${SHORTURLBASE}$,X,"` # DELETE SHORTURLBASE ONLY (-> PRODUCE 404)
      LHERE=L`echo $RANDOM | cut -c 1-3`N
      BHERE=B`echo $RANDOM | cut -c 1-3`R

  INFOSRC="${LONGURL}/info.txt"
  INFOGET=${TMPID}`echo $LONGURL | md5sum | cut -c 1-4`.info

  if [ ! -f $INFOGET ]; then
      getFile "$INFOSRC" "$INFOGET"
  else
     echo "no need to download"
  fi

  if [ X$SUCCESS == XYES ]; then

     write2src "\marginpar{\begin{marginblock}"

     for SECTION in INFO LICENSE COPYRIGHT_HOLDER
      do
       SECTION=`echo $SECTION | sed 's/_/ /g'`
       cat $INFOGET             | # USELESS USE OF CAT
       sed -e :a \
           -e '$!N;s/\n[ \t]*=/ /;ta' \
           -e 'P;D'             | # APPEND UNDERLINE TO PREVIOUS LINE
       sed -n "/${SECTION}[ \t]*=*$/,\$p" | # PRINT FROM REGEX TO END OF FILE
       sed "s/^[ \t]*$/$LHERE/g" | # REMOVE EMPTY LINES
       sed "/=\?=$/s/^/\n/"      | # ADD NEWLINE AT START IF ENDS WITH ==
       sed  '1,/^$/!d'           | # FIRST PARAGRAPH ONLY
       sed "s/$LHERE/ /"         | # RESTORE EMPTY LINES
       grep -v "^[ \t]*$SECTION[ \t]*=*$" | # IGNORE SECTION LINES
       sed "s/$/$BHERE/"          | # PROTECT LINEBREAKS HERE
       pandoc -r markdown -w latex | # FROM MARKDOWN TO LATEX
       sed ':a;N;$!ba;s/\n/ /g' | # REMOVE LINEBREAKS
       sed "s/$BHERE/\n/g"      | # RESTORE LINEBREAKS
       tee >> $SRCDUMP            # WRITE TO FILE
       write2src "" # EMPTY LINE
     done
       write2src "\end{marginblock}}"

      #cp $INFOGET debug.info
      #sleep 5
  else
       echo "file does not exist"
      #write2src "\marginpar{\begin{marginblock}"
      #cat JUNK/info.txt >> $SRCDUMP
      #write2src "\end{marginblock}}"
  fi

}

# --------------------------------------------------------------------------- #





